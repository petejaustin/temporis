#!/usr/bin/env python3
"""
Temporal Benchmark Script for Temporis and Ontime Solvers
Benchmarks both solvers on temporal games generated by generate_games.py

Usage:
    python3 benchmark_temporal_solvers.py <games_dir> [--results-dir <dir>] [--timeout <seconds>]
    
Examples:
    # Benchmark both solvers on all games in benchmark directory
    python3 benchmark_temporal_solvers.py benchmark/
    
    # Custom results directory and timeout
    python3 benchmark_temporal_solvers.py benchmark/ --results-dir results --timeout 60
"""

import os
import subprocess
import time
import json
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Tuple, Optional

def extract_targets_from_dot(dot_file: str) -> List[str]:
    """Extract target nodes from DOT file"""
    targets = []
    try:
        with open(dot_file, 'r') as f:
            for line in f:
                if 'target=1' in line:
                    # Extract node name from line like: v0 [name="v0", player=0, target=1];
                    parts = line.strip().split()
                    if parts:
                        node_name = parts[0]
                        targets.append(node_name)
    except Exception:
        pass
    return targets

def get_game_metadata(meta_file: str) -> Dict:
    """Read game metadata from .meta file"""
    metadata = {"vertices": 0, "time_bound": 0}
    
    if os.path.exists(meta_file):
        try:
            with open(meta_file, 'r') as f:
                for line in f:
                    if ':' in line:
                        key, value = line.strip().split(': ', 1)
                        if key == "vertices":
                            metadata["vertices"] = int(value)
                        elif key == "time_bound":
                            metadata["time_bound"] = int(value)
        except Exception:
            pass
    
    return metadata

def run_temporis_solver(solver_path: str, dot_file: str, timeout: int = 300) -> Dict:
    """Run temporis solver on a .dot file"""
    game_name = Path(dot_file).stem
    
    try:
        start_time = time.time()
        result = subprocess.run(
            [solver_path, '--time-only', dot_file],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        end_time = time.time()
        
        if result.returncode == 0:
            # Extract execution time from temporis output
            execution_time = None
            for line in result.stdout.split('\n'):
                if line.strip() and line.strip().replace('.', '').replace('-', '').isdigit():
                    # Look for numeric output (time in ms)
                    try:
                        execution_time = float(line.strip()) / 1000.0  # Convert ms to seconds
                        break
                    except ValueError:
                        continue
            
            if execution_time is None:
                execution_time = end_time - start_time
            
            return {
                'solver': 'temporis',
                'game': game_name,
                'status': 'success',
                'time': execution_time,
                'output': result.stdout.strip(),
                'timestamp': time.time()
            }
        else:
            return {
                'solver': 'temporis',
                'game': game_name,
                'status': 'failed',
                'error': result.stderr.strip()[:200],
                'timestamp': time.time()
            }
    
    except subprocess.TimeoutExpired:
        return {
            'solver': 'temporis',
            'game': game_name,
            'status': 'timeout',
            'timestamp': time.time()
        }
    except Exception as e:
        return {
            'solver': 'temporis',
            'game': game_name,
            'status': 'error',
            'error': str(e)[:200],
            'timestamp': time.time()
        }

def run_ontime_solver(solver_path: str, tg_file: str, dot_file: str, time_bound: int, timeout: int = 300) -> Dict:
    """Run ontime solver on a .tg file"""
    game_name = Path(tg_file).stem
    
    try:
        # Extract targets from dot file
        targets = extract_targets_from_dot(dot_file)
        if not targets:
            return {
                'solver': 'ontime',
                'game': game_name,
                'status': 'failed',
                'error': 'No targets found in DOT file',
                'timestamp': time.time()
            }
        
        target_set = ",".join(targets)
        
        start_time = time.time()
        result = subprocess.run(
            [solver_path, tg_file, target_set, str(time_bound)],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        end_time = time.time()
        
        execution_time = end_time - start_time
        
        if result.returncode == 0:
            return {
                'solver': 'ontime',
                'game': game_name,
                'status': 'success',
                'time': execution_time,
                'output': result.stdout.strip(),
                'timestamp': time.time()
            }
        else:
            return {
                'solver': 'ontime',
                'game': game_name,
                'status': 'failed',
                'error': result.stderr.strip()[:200],
                'timestamp': time.time()
            }
    
    except subprocess.TimeoutExpired:
        return {
            'solver': 'ontime',
            'game': game_name,
            'status': 'timeout',
            'timestamp': time.time()
        }
    except Exception as e:
        return {
            'solver': 'ontime',
            'game': game_name,
            'status': 'error',
            'error': str(e)[:200],
            'timestamp': time.time()
        }

def find_game_files(games_dir: str) -> List[Tuple[str, str, str]]:
    """Find all game triplets (.tg, .dot, .meta) in the games directory"""
    games_dir = Path(games_dir)
    game_triplets = []
    
    # Find all .meta files and derive the other file names
    for meta_file in games_dir.glob("*.meta"):
        base_name = meta_file.stem
        tg_file = games_dir / f"{base_name}.tg"
        dot_file = games_dir / f"{base_name}.dot"
        
        if tg_file.exists() and dot_file.exists():
            game_triplets.append((str(tg_file), str(dot_file), str(meta_file)))
    
    return sorted(game_triplets)

def run_benchmark(games_dir: str, results_dir: str, timeout: int):
    """Run benchmark on both temporis and ontime solvers"""
    
    # Solver paths
    temporis_path = "/home/pete/temporis/build/temporis"
    ontime_path = "/home/pete/ontime/target/release/ontime"
    
    # Check if solvers exist
    if not os.path.exists(temporis_path):
        print(f"Error: Temporis solver not found at {temporis_path}")
        sys.exit(1)
    
    if not os.path.exists(ontime_path):
        print(f"Error: Ontime solver not found at {ontime_path}")
        sys.exit(1)
    
    # Create results directory
    os.makedirs(results_dir, exist_ok=True)
    
    # Find all game files
    game_triplets = find_game_files(games_dir)
    
    if not game_triplets:
        print(f"No game triplets found in {games_dir}")
        sys.exit(1)
    
    print(f"Found {len(game_triplets)} game triplets")
    print(f"Results will be saved to: {results_dir}")
    print()
    
    all_results = []
    
    for i, (tg_file, dot_file, meta_file) in enumerate(game_triplets, 1):
        game_name = Path(tg_file).stem
        print(f"[{i}/{len(game_triplets)}] Processing {game_name}...")
        
        # Get metadata
        metadata = get_game_metadata(meta_file)
        
        # Run temporis solver
        print(f"  Running temporis...")
        temporis_result = run_temporis_solver(temporis_path, dot_file, timeout)
        temporis_result.update(metadata)
        all_results.append(temporis_result)
        
        print(f"    Status: {temporis_result['status']}")
        if temporis_result['status'] == 'success':
            print(f"    Time: {temporis_result['time']:.6f}s")
        
        # Run ontime solver
        print(f"  Running ontime...")
        ontime_result = run_ontime_solver(ontime_path, tg_file, dot_file, metadata['time_bound'], timeout)
        ontime_result.update(metadata)
        all_results.append(ontime_result)
        
        print(f"    Status: {ontime_result['status']}")
        if ontime_result['status'] == 'success':
            print(f"    Time: {ontime_result['time']:.6f}s")
        print()
    
    # Save consolidated results
    consolidated_file = os.path.join(results_dir, "all_results.json")
    with open(consolidated_file, 'w') as f:
        json.dump(all_results, f, indent=2)
    
    # Print summary
    print("=" * 60)
    print("BENCHMARK SUMMARY")
    print("=" * 60)
    
    temporis_results = [r for r in all_results if r['solver'] == 'temporis']
    ontime_results = [r for r in all_results if r['solver'] == 'ontime']
    
    print(f"Total games: {len(game_triplets)}")
    print()
    
    print("Temporis:")
    temporis_success = len([r for r in temporis_results if r['status'] == 'success'])
    temporis_failed = len([r for r in temporis_results if r['status'] == 'failed'])
    temporis_timeout = len([r for r in temporis_results if r['status'] == 'timeout'])
    temporis_error = len([r for r in temporis_results if r['status'] == 'error'])
    
    print(f"  Success: {temporis_success}")
    print(f"  Failed:  {temporis_failed}")
    print(f"  Timeout: {temporis_timeout}")
    print(f"  Error:   {temporis_error}")
    
    if temporis_success > 0:
        successful_times = [r['time'] for r in temporis_results if r['status'] == 'success']
        print(f"  Avg time: {sum(successful_times) / len(successful_times):.6f}s")
        print(f"  Min time: {min(successful_times):.6f}s")
        print(f"  Max time: {max(successful_times):.6f}s")
    
    print()
    print("Ontime:")
    ontime_success = len([r for r in ontime_results if r['status'] == 'success'])
    ontime_failed = len([r for r in ontime_results if r['status'] == 'failed'])
    ontime_timeout = len([r for r in ontime_results if r['status'] == 'timeout'])
    ontime_error = len([r for r in ontime_results if r['status'] == 'error'])
    
    print(f"  Success: {ontime_success}")
    print(f"  Failed:  {ontime_failed}")
    print(f"  Timeout: {ontime_timeout}")
    print(f"  Error:   {ontime_error}")
    
    if ontime_success > 0:
        successful_times = [r['time'] for r in ontime_results if r['status'] == 'success']
        print(f"  Avg time: {sum(successful_times) / len(successful_times):.6f}s")
        print(f"  Min time: {min(successful_times):.6f}s")
        print(f"  Max time: {max(successful_times):.6f}s")
    
    print()
    print(f"Results saved to: {results_dir}")
    print(f"Consolidated results: {consolidated_file}")

def main():
    parser = argparse.ArgumentParser(description='Benchmark temporal solvers on generated games')
    parser.add_argument('games_dir', help='Directory containing generated game files (.tg, .dot, .meta)')
    parser.add_argument('--results-dir', default='temporal_benchmark_results', 
                       help='Directory to save results (default: temporal_benchmark_results)')
    parser.add_argument('--timeout', type=int, default=300, 
                       help='Timeout per game in seconds (default: 300)')
    
    args = parser.parse_args()
    
    if not os.path.isdir(args.games_dir):
        print(f"Error: Games directory '{args.games_dir}' does not exist")
        sys.exit(1)
    
    run_benchmark(args.games_dir, args.results_dir, args.timeout)

if __name__ == "__main__":
    main()
